{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-eed07f61939757c9c1e7816a56dc3fcd60b797d0",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/DocumentVerification.sol": "project/contracts/DocumentVerification.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/DocumentVerification.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/**\r\n * @title DocumentVerification\r\n * @dev Smart Contract để xác thực tài liệu thông qua hash và lưu trữ metadata trên blockchain\r\n */\r\ncontract DocumentVerification {\r\n    \r\n    // Struct để lưu thông tin tài liệu\r\n    struct Document {\r\n        bytes32 documentHash;      // SHA-256 hash của tài liệu\r\n        string ipfsCID;            // IPFS Content Identifier\r\n        address uploader;          // Địa chỉ người upload\r\n        uint256 timestamp;         // Thời gian upload\r\n        string metadata;           // Metadata bổ sung (tên file, mô tả, etc.)\r\n        bool exists;               // Flag kiểm tra tài liệu có tồn tại\r\n    }\r\n    \r\n    // mapping: là map bytes32(sha256 có 32 bytes) vào struct Documents\r\n    // Ví dụ : hash1 → {ipfsCID: \"Qm1...\", uploader: Alice, ...} => Để mỗi hashvalue CHỈ map với 1 document\r\n    // Mapping: hash -> Document\r\n    mapping(bytes32 => Document) private documents;\r\n    \r\n    // địa chỉ ví(address) => bytes32(hashvalue) : để mỗi address sẽ tìm được các hashvalue(tài liệu) cần tìm)\r\n    // Mapping: uploader -> danh sách hash của họ\r\n    mapping(address => bytes32[]) private uploaderDocuments;\r\n    \r\n    // Array lưu tất cả hash (để duyệt nếu cần)\r\n    bytes32[] private allDocumentHashes;\r\n    \r\n    // Events\r\n    // Cài đặt cấu trúc logging(log vào blockchain)\r\n    event DocumentRecorded(\r\n        bytes32 indexed documentHash, // searchable\r\n        string ipfsCID,\r\n        address indexed uploader,\r\n        uint256 timestamp,\r\n        bytes32 indexed txHash\r\n    );\r\n    \r\n    event DocumentVerified(\r\n        bytes32 indexed documentHash,\r\n        address indexed verifier,\r\n        bool isValid,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    // Modifiers : tạo ra các rule để verify các hash\r\n    modifier onlyExistingDocument(bytes32 _hash) {\r\n        require(documents[_hash].exists, \"Document does not exist\");\r\n        _; // run the rest of the function\r\n    }\r\n    \r\n    modifier onlyNewDocument(bytes32 _hash) {\r\n        require(!documents[_hash].exists, \"Document already exists\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Upload tài liệu mới lên blockchain\r\n     * @param _documentHash SHA-256 hash của tài liệu (bytes32)\r\n     * @param _ipfsCID IPFS Content ID\r\n     * @param _metadata Metadata bổ sung (JSON string hoặc plain text)\r\n     */\r\n    function uploadDocument(\r\n        bytes32 _documentHash,\r\n        string memory _ipfsCID,\r\n        string memory _metadata\r\n    ) public onlyNewDocument(_documentHash) {\r\n        require(_documentHash != bytes32(0), \"Invalid document hash\");\r\n        require(bytes(_ipfsCID).length > 0, \"IPFS CID cannot be empty\");\r\n        \r\n        // Tạo document mới\r\n        Document memory newDoc = Document({\r\n            documentHash: _documentHash,\r\n            ipfsCID: _ipfsCID,\r\n            uploader: msg.sender,\r\n            timestamp: block.timestamp,\r\n            metadata: _metadata,\r\n            exists: true\r\n        });\r\n        \r\n        // Lưu vào mapping\r\n        documents[_documentHash] = newDoc;\r\n        \r\n        // Lưu vào danh sách của uploader\r\n        uploaderDocuments[msg.sender].push(_documentHash);\r\n        \r\n        // Lưu vào danh sách tổng\r\n        allDocumentHashes.push(_documentHash);\r\n        \r\n        // Emit event với txHash (block.timestamp dùng làm pseudo txHash)\r\n        emit DocumentRecorded(\r\n            _documentHash,\r\n            _ipfsCID,\r\n            msg.sender,\r\n            block.timestamp,\r\n            keccak256(abi.encodePacked(_documentHash, msg.sender, block.timestamp))\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @dev Xác thực tài liệu bằng hash\r\n     * @param _documentHash Hash cần kiểm tra\r\n     * @return isValid Tài liệu có tồn tại và hợp lệ không\r\n     * @return ipfsCID IPFS CID nếu tìm thấy\r\n     * @return uploader Địa chỉ người upload\r\n     * @return timestamp Thời gian upload\r\n     * @return metadata Metadata của tài liệu\r\n     */\r\n    function verifyDocument(bytes32 _documentHash) \r\n        public \r\n        returns (\r\n            bool isValid,\r\n            string memory ipfsCID,\r\n            address uploader,\r\n            uint256 timestamp,\r\n            string memory metadata\r\n        ) \r\n    {\r\n        Document memory doc = documents[_documentHash];\r\n        \r\n        isValid = doc.exists;\r\n        \r\n        if (isValid) {\r\n            ipfsCID = doc.ipfsCID;\r\n            uploader = doc.uploader;\r\n            timestamp = doc.timestamp;\r\n            metadata = doc.metadata;\r\n        }\r\n        \r\n        // Emit event để tracking\r\n        emit DocumentVerified(_documentHash, msg.sender, isValid, block.timestamp);\r\n        \r\n        return (isValid, ipfsCID, uploader, timestamp, metadata);\r\n    }\r\n    \r\n    /**\r\n     * @dev Lấy thông tin tài liệu (view function - không tốn gas)\r\n     * @param _documentHash Hash cần tra cứu\r\n     */\r\n    function getDocument(bytes32 _documentHash) \r\n        public \r\n        view \r\n        onlyExistingDocument(_documentHash)\r\n        returns (\r\n            string memory ipfsCID,\r\n            address uploader,\r\n            uint256 timestamp,\r\n            string memory metadata\r\n        ) \r\n    {\r\n        Document memory doc = documents[_documentHash];\r\n        return (doc.ipfsCID, doc.uploader, doc.timestamp, doc.metadata);\r\n    }\r\n    \r\n    /**\r\n     * @dev Kiểm tra tài liệu có tồn tại không (view function)\r\n     * @param _documentHash Hash cần kiểm tra\r\n     */\r\n    function documentExists(bytes32 _documentHash) public view returns (bool) {\r\n        return documents[_documentHash].exists;\r\n    }\r\n    \r\n    /**\r\n     * @dev Lấy danh sách hash của một uploader\r\n     * @param _uploader Địa chỉ uploader\r\n     */\r\n    function getDocumentsByUploader(address _uploader) \r\n        public \r\n        view \r\n        returns (bytes32[] memory) \r\n    {\r\n        return uploaderDocuments[_uploader];\r\n    }\r\n    \r\n    /**\r\n     * @dev Lấy tổng số tài liệu đã upload\r\n     */\r\n    function getTotalDocuments() public view returns (uint256) {\r\n        return allDocumentHashes.length;\r\n    }\r\n    \r\n    /**\r\n     * @dev Lấy hash tài liệu theo index (để pagination)\r\n     * @param _index Index trong array\r\n     */\r\n    function getDocumentHashByIndex(uint256 _index) \r\n        public \r\n        view \r\n        returns (bytes32) \r\n    {\r\n        require(_index < allDocumentHashes.length, \"Index out of bounds\");\r\n        return allDocumentHashes[_index];\r\n    }\r\n    \r\n    /**\r\n     * @dev Lấy danh sách tài liệu với pagination\r\n     * @param _offset Vị trí bắt đầu\r\n     * @param _limit Số lượng tối đa\r\n     */\r\n    function getDocumentsPaginated(uint256 _offset, uint256 _limit)\r\n        public\r\n        view\r\n        returns (bytes32[] memory hashes, uint256 total)\r\n    {\r\n        total = allDocumentHashes.length;\r\n        \r\n        if (_offset >= total) {\r\n            return (new bytes32[](0), total);\r\n        }\r\n        \r\n        uint256 end = _offset + _limit;\r\n        if (end > total) {\r\n            end = total;\r\n        }\r\n        \r\n        uint256 size = end - _offset;\r\n        hashes = new bytes32[](size);\r\n        \r\n        for (uint256 i = 0; i < size; i++) {\r\n            hashes[i] = allDocumentHashes[_offset + i];\r\n        }\r\n        \r\n        return (hashes, total);\r\n    }\r\n}"
      }
    }
  }
}